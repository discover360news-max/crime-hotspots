---
/**
 * TopRegionsCard Component
 * Displays top 10 areas ranked by crime count with risk level bars
 * Data updates dynamically via JavaScript when filters change
 */

import AreaNameTooltip from './AreaNameTooltip.astro';
import InfoPopup from './InfoPopup.astro';
import { loadAreaAliases, getLocalName } from '../lib/areaAliases';
import { getRiskWeight } from '../config/riskWeights';
import { usesVictimCount } from '../config/crimeTypeConfig';

interface Crime {
  area: string;
  primaryCrimeType?: string;
  crimeType?: string;
  relatedCrimeTypes?: string;
  victimCount?: number;
  [key: string]: any;
}

interface Props {
  crimes: Crime[];
}

const { crimes } = Astro.props;

// Load area aliases for tooltips
const areaAliases = await loadAreaAliases();

// Calculate risk score for a single crime
function calculateCrimeRisk(crime: Crime): number {
  let riskScore = 0;

  // Calculate primary crime risk
  const primaryType = crime.primaryCrimeType || crime.crimeType;
  if (primaryType) {
    const weight = getRiskWeight(primaryType);
    const victimCount = usesVictimCount(primaryType) && crime.victimCount ? crime.victimCount : 1;
    riskScore += weight * victimCount;
  }

  // Calculate related crimes risk (always Ã— 1, no victim multiplier)
  if (crime.relatedCrimeTypes) {
    const relatedTypes = crime.relatedCrimeTypes.split(',').map(t => t.trim()).filter(t => t);
    relatedTypes.forEach(relatedType => {
      const weight = getRiskWeight(relatedType);
      riskScore += weight * 1; // Always count as 1 for related crimes
    });
  }

  return riskScore;
}

// Calculate risk scores for all areas
const areaRiskScores = new Map<string, number>();
crimes.forEach(crime => {
  const area = crime.area || 'Unknown';
  const riskScore = calculateCrimeRisk(crime);
  areaRiskScores.set(area, (areaRiskScores.get(area) || 0) + riskScore);
});

// Find maximum risk score for normalization
const maxRiskScore = Math.max(...Array.from(areaRiskScores.values()), 0);

// Calculate top areas with risk percentages
const areaCounts = Array.from(
  crimes.reduce((acc, crime) => {
    const area = crime.area || 'Unknown';
    acc.set(area, (acc.get(area) || 0) + 1);
    return acc;
  }, new Map<string, number>())
)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([area, count]) => {
    const riskScore = areaRiskScores.get(area) || 0;
    const riskPercentage = maxRiskScore > 0 ? Math.round((riskScore / maxRiskScore) * 100) : 0;
    return { area, count, riskPercentage };
  });

// Get risk level text based on percentage
function getRiskLevelText(percentage: number): string {
  if (percentage <= 16) {
    return 'Low';
  } else if (percentage <= 33) {
    return 'Medium';
  } else if (percentage <= 50) {
    return 'Concerning';
  } else if (percentage <= 66) {
    return 'High';
  } else if (percentage <= 83) {
    return 'Dangerous';
  } else {
    return 'Extremely Dangerous';
  }
}

// Get text color based on risk level
function getRiskTextColor(percentage: number): string {
  if (percentage <= 33) {
    return 'text-green-600';
  } else if (percentage <= 66) {
    return 'text-yellow-600';
  } else {
    return 'text-rose-600';
  }
}
---

<div id="topRegionsCard" class="bg-white/70 backdrop-blur-md rounded-lg p-4 shadow-md">
  <div class="flex items-center gap-2 mb-4">
    <h3 class="text-h3 font-bold text-slate-700">Top Areas</h3>
    <InfoPopup id="top-areas-risk-info">
      <p class="font-semibold mb-2 text-slate-700">Understanding Risk Assessment</p>
      <p class="mb-3">Each area's risk level is calculated based on crime severity and victim impact.</p>
      <p class="font-semibold mb-2 text-slate-700">How It Works:</p>
      <ul class="list-disc list-inside space-y-1 mb-3">
        <li>Each crime type has a severity weight (Murder=10, Theft=2, etc.)</li>
        <li>Victim counts multiply risk for serious crimes</li>
        <li>Area risk = sum of all crime risk scores</li>
        <li>Bar shows percentage relative to highest-risk area</li>
      </ul>
      <p class="font-semibold mb-2 text-slate-700">Color Guide:</p>
      <ul class="list-disc list-inside space-y-1">
        <li><span class="text-green-600 font-medium">Green</span>: Low risk (0-33%)</li>
        <li><span class="text-yellow-600 font-medium">Yellow</span>: Medium risk (34-66%)</li>
        <li><span class="text-rose-600 font-medium">Red</span>: High risk (67-100%)</li>
      </ul>
    </InfoPopup>
  </div>
  <div id="topRegionsContainer" class="grid grid-cols-2 gap-x-4 gap-y-3">
    {areaCounts.map(({ area, count, riskPercentage }) => {
      const localName = getLocalName(areaAliases, area);
      const riskLevelText = getRiskLevelText(riskPercentage);
      const riskTextColor = getRiskTextColor(riskPercentage);
      return (
        <div class="flex flex-col gap-1 pb-3 border-b border-slate-200">
          <div class="flex justify-between items-center gap-2">
            <span class="text-xs text-slate-500 truncate flex-1">
              <AreaNameTooltip area={area} localName={localName} />
            </span>
            <span class="px-2 py-1 min-h-[22px] flex items-center justify-center rounded-full bg-rose-600 text-white text-xs font-medium flex-shrink-0">
              {count}
            </span>
          </div>
          <!-- Gradient reveal bar -->
          <div class="relative w-full h-2 bg-slate-200 rounded-full overflow-hidden">
            <!-- Gradient bar wrapper (clips at percentage) -->
            <div class="absolute top-0 left-0 h-full overflow-hidden transition-all duration-300" style={`width: ${riskPercentage}%`}>
              <!-- Gradient spans full container width, clipped by wrapper -->
              <div class="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-rose-600" style={`width: ${riskPercentage > 0 ? (100 / riskPercentage) * 100 : 100}%`}></div>
            </div>
          </div>
          <!-- Risk level text -->
          <span class={`text-xs font-medium ${riskTextColor}`}>Risk: {riskLevelText}</span>
        </div>
      );
    })}
  </div>
</div>
