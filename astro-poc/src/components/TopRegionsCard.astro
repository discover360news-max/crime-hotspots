---
/**
 * TopRegionsCard Component
 * Displays top 10 areas ranked by crime count with risk level bars
 * Data updates dynamically via JavaScript when filters change
 */

import AreaNameTooltip from './AreaNameTooltip.astro';
import { loadAreaAliases, getLocalName } from '../lib/areaAliases';
import { generateNameSlug } from '../lib/crimeData';
import { getRiskWeight } from '../config/riskWeights';
import { usesVictimCount } from '../config/crimeTypeConfig';

interface Crime {
  area: string;
  primaryCrimeType?: string;
  crimeType?: string;
  relatedCrimeTypes?: string;
  victimCount?: number;
  [key: string]: any;
}

interface Props {
  crimes: Crime[];
}

const { crimes } = Astro.props;

// Load area aliases for tooltips
const areaAliases = await loadAreaAliases();

// Calculate risk score for a single crime
function calculateCrimeRisk(crime: Crime): number {
  let riskScore = 0;

  // Calculate primary crime risk
  const primaryType = crime.primaryCrimeType || crime.crimeType;
  if (primaryType) {
    const weight = getRiskWeight(primaryType);
    const victimCount = usesVictimCount(primaryType) && crime.victimCount ? crime.victimCount : 1;
    riskScore += weight * victimCount;
  }

  // Calculate related crimes risk (always × 1, no victim multiplier)
  if (crime.relatedCrimeTypes) {
    const relatedTypes = crime.relatedCrimeTypes.split(',').map(t => t.trim()).filter(t => t);
    relatedTypes.forEach(relatedType => {
      const weight = getRiskWeight(relatedType);
      riskScore += weight * 1; // Always count as 1 for related crimes
    });
  }

  return riskScore;
}

// Calculate risk scores for all areas
const areaRiskScores = new Map<string, number>();
crimes.forEach(crime => {
  const area = crime.area || 'Unknown';
  const riskScore = calculateCrimeRisk(crime);
  areaRiskScores.set(area, (areaRiskScores.get(area) || 0) + riskScore);
});

// Sum total risk across ALL areas (denominator for share-of-total normalization)
const totalRiskScore = Array.from(areaRiskScores.values()).reduce((sum, s) => sum + s, 0);

// Calculate top areas — each area's % = its share of total weighted crime burden
const areaCounts = Array.from(
  crimes.reduce((acc, crime) => {
    const area = crime.area || 'Unknown';
    acc.set(area, (acc.get(area) || 0) + 1);
    return acc;
  }, new Map<string, number>())
)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([area, count]) => {
    const riskScore = areaRiskScores.get(area) || 0;
    const riskPercentage = totalRiskScore > 0 ? Math.round((riskScore / totalRiskScore) * 100) : 0;
    return { area, count, riskPercentage };
  });

// Get risk level text based on share of total weighted crime burden.
// Thresholds calibrated for share-of-total: dominant area typically 20-40%,
// average top-10 area ~5-10%, smaller areas <3%.
function getRiskLevelText(percentage: number): string {
  if (percentage <= 3) {
    return 'Low';
  } else if (percentage <= 8) {
    return 'Medium';
  } else if (percentage <= 15) {
    return 'Concerning';
  } else if (percentage <= 25) {
    return 'High';
  } else if (percentage <= 40) {
    return 'Dangerous';
  } else {
    return 'Extremely Dangerous';
  }
}

// Get text color based on risk level (share-of-total thresholds)
function getRiskTextColor(percentage: number): string {
  if (percentage <= 8) {
    return 'text-green-600';
  } else if (percentage <= 25) {
    return 'text-yellow-600';
  } else {
    return 'text-rose-600';
  }
}
---

<div class="bg-white/85 dark:bg-[hsl(0_0%_8%)]/85 backdrop-blur-md rounded-lg p-4 shadow-md border border-slate-100 dark:border-[hsl(0_0%_15%)]">
  <div id="topRegionsContainer" class="grid grid-cols-2 gap-x-8 gap-y-3">
    {areaCounts.map(({ area, count, riskPercentage }) => {
      const localName = getLocalName(areaAliases, area);
      const riskLevelText = getRiskLevelText(riskPercentage);
      const riskTextColor = getRiskTextColor(riskPercentage);
      const areaSlug = generateNameSlug(area);
      return (
        <a href={`/trinidad/area/${areaSlug}/`} class="flex flex-col gap-1 pb-3 border-b border-slate-200 dark:border-[hsl(0_0%_18%)] hover:bg-slate-50 dark:hover:bg-[hsl(0_0%_12%)] active:bg-slate-50 dark:active:bg-[hsl(0_0%_12%)] rounded-lg px-2 -mx-2 py-2 transition">
          <div class="flex justify-between items-center gap-2">
            <span class="text-xs text-slate-500 dark:text-[hsl(0_0%_55%)] truncate flex-1">
              <AreaNameTooltip area={area} localName={localName} />
            </span>
            <div class="flex items-center gap-1.5 flex-shrink-0">
              <span class="px-1.5 py-0.5 min-h-[20px] flex items-center justify-center rounded-full bg-slate-200 dark:bg-[hsl(0_0%_20%)] text-slate-600 dark:text-[hsl(0_0%_55%)] text-xs font-medium">
                {count}
              </span>
              <span class="text-xs text-slate-500 dark:text-[hsl(0_0%_55%)]">{count === 1 ? 'crime' : 'crimes'}</span>
              <svg class="w-3.5 h-3.5 text-slate-400 dark:text-[hsl(0_0%_50%)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
          <!-- Gradient reveal bar -->
          <div class="relative w-full h-2 bg-slate-200 dark:bg-[hsl(0_0%_18%)] rounded-full overflow-hidden">
            <!-- Gradient bar wrapper (clips at percentage) -->
            <div class="absolute top-0 left-0 h-full overflow-hidden transition-all duration-300" style={`width: ${riskPercentage}%`}>
              <!-- Gradient spans full container width, clipped by wrapper -->
              <div class="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-rose-600" style={`width: ${riskPercentage > 0 ? (100 / riskPercentage) * 100 : 100}%`}></div>
            </div>
          </div>
          <!-- Risk level text -->
          <span class={`text-xs font-medium ${riskTextColor}`}>Risk: {riskLevelText}</span>
        </a>
      );
    })}
  </div>
</div>
