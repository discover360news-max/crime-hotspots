---
/**
 * TopRegionsCard Component
 * Displays top 10 areas ranked by crime count with risk level bars
 * Data updates dynamically via JavaScript when filters change
 */

import AreaNameTooltip from './AreaNameTooltip.astro';
import { loadAreaAliases, getLocalName } from '../lib/areaAliases';
import { generateNameSlug } from '../lib/crimeData';
import { getRiskWeight } from '../config/riskWeights';
import { usesVictimCount } from '../config/crimeTypeConfig';

interface Crime {
  area: string;
  primaryCrimeType?: string;
  crimeType?: string;
  relatedCrimeTypes?: string;
  victimCount?: number;
  [key: string]: any;
}

interface Props {
  crimes: Crime[];
}

const { crimes } = Astro.props;

// Load area aliases for tooltips
const areaAliases = await loadAreaAliases();

// Calculate risk score for a single crime
function calculateCrimeRisk(crime: Crime): number {
  let riskScore = 0;

  // Calculate primary crime risk
  const primaryType = crime.primaryCrimeType || crime.crimeType;
  if (primaryType) {
    const weight = getRiskWeight(primaryType);
    const victimCount = usesVictimCount(primaryType) && crime.victimCount ? crime.victimCount : 1;
    riskScore += weight * victimCount;
  }

  // Calculate related crimes risk (always Ã— 1, no victim multiplier)
  if (crime.relatedCrimeTypes) {
    const relatedTypes = crime.relatedCrimeTypes.split(',').map(t => t.trim()).filter(t => t);
    relatedTypes.forEach(relatedType => {
      const weight = getRiskWeight(relatedType);
      riskScore += weight * 1; // Always count as 1 for related crimes
    });
  }

  return riskScore;
}

// Calculate risk scores for all areas
const areaRiskScores = new Map<string, number>();
crimes.forEach(crime => {
  const area = crime.area || 'Unknown';
  const riskScore = calculateCrimeRisk(crime);
  areaRiskScores.set(area, (areaRiskScores.get(area) || 0) + riskScore);
});

// Find maximum risk score for normalization
const maxRiskScore = Math.max(...Array.from(areaRiskScores.values()), 0);

// Calculate top areas with risk percentages
const areaCounts = Array.from(
  crimes.reduce((acc, crime) => {
    const area = crime.area || 'Unknown';
    acc.set(area, (acc.get(area) || 0) + 1);
    return acc;
  }, new Map<string, number>())
)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([area, count]) => {
    const riskScore = areaRiskScores.get(area) || 0;
    const riskPercentage = maxRiskScore > 0 ? Math.round((riskScore / maxRiskScore) * 100) : 0;
    return { area, count, riskPercentage };
  });

// Get risk level text based on percentage
function getRiskLevelText(percentage: number): string {
  if (percentage <= 16) {
    return 'Low';
  } else if (percentage <= 33) {
    return 'Medium';
  } else if (percentage <= 50) {
    return 'Concerning';
  } else if (percentage <= 66) {
    return 'High';
  } else if (percentage <= 83) {
    return 'Dangerous';
  } else {
    return 'Extremely Dangerous';
  }
}

// Get text color based on risk level
function getRiskTextColor(percentage: number): string {
  if (percentage <= 33) {
    return 'text-green-600';
  } else if (percentage <= 66) {
    return 'text-yellow-600';
  } else {
    return 'text-rose-600';
  }
}
---

<div class="bg-white/70 backdrop-blur-md rounded-lg p-4 shadow-md">
  <div id="topRegionsContainer" class="grid grid-cols-2 gap-x-4 gap-y-3">
    {areaCounts.map(({ area, count, riskPercentage }) => {
      const localName = getLocalName(areaAliases, area);
      const riskLevelText = getRiskLevelText(riskPercentage);
      const riskTextColor = getRiskTextColor(riskPercentage);
      const areaSlug = generateNameSlug(area);
      return (
        <a href={`/trinidad/area/${areaSlug}`} class="flex flex-col gap-1 pb-3 border-b border-slate-200 hover:bg-slate-50 active:bg-slate-50 rounded-lg px-2 -mx-2 py-2 transition">
          <div class="flex justify-between items-center gap-2">
            <span class="text-xs text-slate-500 truncate flex-1 underline decoration-slate-300 underline-offset-2">
              <AreaNameTooltip area={area} localName={localName} />
            </span>
            <div class="flex items-center gap-1.5 flex-shrink-0">
              <span class="px-2 py-1 min-h-[22px] flex items-center justify-center rounded-full bg-rose-600 text-white text-xs font-medium">
                {count}
              </span>
              <svg class="w-3.5 h-3.5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
          </div>
          <!-- Gradient reveal bar -->
          <div class="relative w-full h-2 bg-slate-200 rounded-full overflow-hidden">
            <!-- Gradient bar wrapper (clips at percentage) -->
            <div class="absolute top-0 left-0 h-full overflow-hidden transition-all duration-300" style={`width: ${riskPercentage}%`}>
              <!-- Gradient spans full container width, clipped by wrapper -->
              <div class="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-rose-600" style={`width: ${riskPercentage > 0 ? (100 / riskPercentage) * 100 : 100}%`}></div>
            </div>
          </div>
          <!-- Risk level text -->
          <span class={`text-xs font-medium ${riskTextColor}`}>Risk: {riskLevelText}</span>
        </a>
      );
    })}
  </div>
</div>
